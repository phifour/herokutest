{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/js/app.js","src/js/ctrl/dataview.controller.js","src/js/ctrl/geospatial.controller.js","src/js/ctrl/keymetrics.controller.js","src/js/ctrl/main.controller.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"app.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var app = angular.module('app', ['ui.router', 'ui.bootstrap', 'firebase', 'ngCookies','uiGmapgoogle-maps','nvd3','ngTable']);//, \r\n\r\napp.config(['$stateProvider', '$urlRouterProvider',\r\n    function ($stateProvider, $urlRouterProvider) {\r\n\r\n        //Problem with injection\r\n        //,$stateParams\r\n\r\n        // For unmatched routes\r\n        $urlRouterProvider.otherwise('/');\r\n\r\n        // Application routes\r\n        $stateProvider\r\n            .state('index', {\r\n                url: '/',\r\n                templateUrl: 'layouts/dashboard.html'\r\n            })\r\n            .state('data', {\r\n                url: '/data',\r\n                templateUrl: 'layouts/data.html'\r\n            })\r\n            .state('keymetrics', {\r\n                url: '/keymetrics',\r\n                templateUrl: 'layouts/keymetrics.html'\r\n            })            \r\n    }\r\n]);\r\n\r\n/**\r\n * Widget Header Directive\r\n */\r\n\r\napp.directive('rdWidgetHeader', rdWidgetTitle);\r\n\r\nfunction rdWidgetTitle() {\r\n    var directive = {\r\n        requires: '^rdWidget',\r\n        scope: {\r\n            title: '@',\r\n            icon: '@'\r\n        },\r\n        transclude: true,\r\n        template: '<div class=\"widget-header\"><div class=\"row\"><div class=\"pull-left\"><i class=\"fa\" ng-class=\"icon\"></i> {{title}} </div><div class=\"pull-right col-xs-6 col-sm-4\" ng-transclude></div></div></div>',\r\n        restrict: 'E'\r\n    };\r\n    return directive;\r\n};\r\n\r\napp.directive('rdWidgetFooter', rdWidgetFooter);\r\n\r\nfunction rdWidgetFooter() {\r\n    var directive = {\r\n        requires: '^rdWidget',\r\n        transclude: true,\r\n        template: '<div class=\"widget-footer\" ng-transclude></div>',\r\n        restrict: 'E'\r\n    };\r\n    return directive;\r\n};\r\n\r\n\r\napp.directive('rdWidgetBody', rdWidgetBody);\r\n\r\nfunction rdWidgetBody() {\r\n    var directive = {\r\n        requires: '^rdWidget',\r\n        scope: {\r\n            loading: '@?',\r\n            classes: '@?'\r\n        },\r\n        transclude: true,\r\n        template: '<div class=\"widget-body\" ng-class=\"classes\"><rd-loading ng-show=\"loading\"></rd-loading><div ng-hide=\"loading\" class=\"widget-content\" ng-transclude></div></div>',\r\n        restrict: 'E'\r\n    };\r\n    return directive;\r\n};\r\n\r\napp.directive('rdWidget', rdWidget);\r\n\r\nfunction rdWidget() {\r\n    var directive = {\r\n        transclude: true,\r\n        template: '<div class=\"widget\" ng-transclude></div>',\r\n        restrict: 'EA'\r\n    };\r\n    return directive;\r\n\r\n    function link(scope, element, attrs) {\r\n        /* */\r\n    }\r\n};\r\n\r\napp.directive('rdLoading', rdLoading);\r\n\r\nfunction rdLoading() {\r\n    var directive = {\r\n        restrict: 'AE',\r\n        template: '<div class=\"loading\"><div class=\"double-bounce1\"></div><div class=\"double-bounce2\"></div></div>'\r\n    };\r\n    return directive;\r\n};\r\n\r\n","app.controller('DataViewCtrl', ['$scope', '$element', '$window', '$http', '$interval', 'NgTableParams', DataViewCtrl]);\r\n\r\nfunction DataViewCtrl($scope, $element, $window, $http, $interval, NgTableParams) {\r\n\r\n    var update_interval = 3000;\r\n\r\n    var mobileView = 992;\r\n\r\n    $scope.dataupdate = false;\r\n\r\n    $scope.mobiletable = [];\r\n\r\n    $scope.iframeHeight = window.innerHeight;\r\n\r\n\r\n    var w = angular.element($window);\r\n    $scope.$watch(\r\n        function () {\r\n            return $window.innerWidth;\r\n        },\r\n        function (value) {\r\n            $scope.windowWidth = value;\r\n        },\r\n        true\r\n        );\r\n\r\n    w.bind('resize', function () {\r\n        $scope.$apply();\r\n    });\r\n\r\n\r\n    $scope.issuesclosed = 0;\r\n    $scope.issuesopen = 0;\r\n\r\n    var init_load = false;\r\n\r\n    function loaddata() {\r\n\r\n        $scope.dataupdate = false;\r\n\r\n        d3.csv(\"data/issues.csv\", function (d) {\r\n            return {\r\n                customername: d['Customer name'],\r\n                subtimestamp: Date.parse(d['Submission Timestamp']),\r\n                email: d['customer email address'],\r\n                description: d['Description'],\r\n                status: d['Status'],\r\n                closedtimestamp: Date.parse(d['Closed Timestamp']),\r\n                employeename: d['Employee name']\r\n            };\r\n        }, function (data) {\r\n            $scope.issuesclosed = 0;\r\n            $scope.issuesopen = 0;\r\n            for (var i = 0; i < data.length; i++) {\r\n                if (data[i].status == \"Closed\") {\r\n                    $scope.issuesclosed = $scope.issuesclosed + 1;\r\n                    console.log('Issue open', $scope.issuesclosed);\r\n                } else {\r\n                    $scope.issuesopen = $scope.issuesopen + 1;\r\n                }\r\n            }\r\n\r\n            $scope.mobiletable = data;\r\n\r\n            console.log('Data!!!', data);\r\n\r\n            $scope.tp = new NgTableParams({}, { dataset: data });\r\n        });\r\n\r\n    };\r\n\r\n    $scope.callAtInterval = loaddata;\r\n      \r\n    //init load of data at program start \r\n    if (init_load == false) {\r\n        loaddata();\r\n        init_load = true;\r\n    }\r\n\r\n    var stopTime = $interval(function () { $scope.callAtInterval(); }, update_interval, false);\r\n\r\n    $element.on('$destroy', function () {\r\n        $interval.cancel(stopTime);\r\n    });\r\n\r\n\r\n}","app.controller('GeoSpatialCtrl', ['$scope', '$element', '$http', '$interval', 'NgTableParams', GeoSpatialCtrl]);\r\n\r\nfunction GeoSpatialCtrl($scope, $element, $http, $interval, NgTableParams) {\r\n    \r\n    var update_interval = 3000;\r\n\r\n    $scope.dataupdate = false;\r\n\r\n    $scope.map = { center: { latitude: 48.20705775, longitude: 16.38044357 }, zoom: 8 };\r\n\r\n    $scope.places = [];\r\n    \r\n    function loaddata() {\r\n        \r\n        $scope.dataupdate = false;\r\n        \r\n        $http.get(\"data/stations.json\").then(function (response) {\r\n            return response.data.stations;\r\n        }).then(function (places) {\r\n\r\n            if ($scope.places.length != places.length) {\r\n                $scope.dataupdate = !$scope.dataupdate;\r\n            } else {\r\n\r\n                if ($scope.places.length > 0) {\r\n                    for (var i = 0; i < places.length; i++) {\r\n                        if (places[i].title != $scope.places[i].title){\r\n                            console.log('$scope.places[i]xx',$scope.places[i]);\r\n                            console.log('NE check',places[i].title,$scope.places[i].title);\r\n                            $scope.dataupdate = true;\r\n                        }\r\n                        if (places[i].employees != $scope.places[i].employees) {\r\n                            $scope.dataupdate = true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            console.log('$scope.dataupdate',$scope.dataupdate);\r\n\r\n            for (var i = 0; i < places.length; i++) {\r\n                places[i]['options'] = { labelClass: 'labels', labelAnchor: '12 60', labelContent: places[i].title + ' , employees: ' + places[i].employees };\r\n            }\r\n\r\n            $scope.places = places;\r\n        });\r\n    }\r\n\r\n    $scope.callAtInterval = loaddata;\r\n\r\n    var stopTime = $interval(function () { $scope.callAtInterval(); }, update_interval, false);\r\n\r\n    $element.on('$destroy', function () {\r\n        $interval.cancel(stopTime);\r\n    });\r\n\r\n\r\n\r\n\r\n}","app.controller('KeyMetricsCtrl', ['$scope', '$element', '$http', '$interval', 'NgTableParams', '$firebaseArray',  KeyMetricsCtrl]);\r\n\r\nfunction KeyMetricsCtrl($scope, $element, $http, $interval, NgTableParams, $firebaseArray) {\r\n\r\n    var update_interval = 3000;\r\n\r\n    var mobileView = 992;\r\n    \r\n    var ref = new Firebase(\"https://flickering-inferno-6917.firebaseio.com/temperature\");\r\n\r\n    var temp = $firebaseArray(ref);\r\n\r\n    var sin = [];\r\n\r\n     // to take an action after the data loads, use the $loaded() promise\r\n     temp.$loaded().then(function() {\r\n        console.log(\"loaded record:\", temp);\r\n        loaddata();\r\n       // To iterate the key/value pairs of the object, use angular.forEach()\r\n     });\r\n\r\n    //Data is represented as an array of {x,y} pairs.\r\n    for (var i = 0; i < 100; i++) {\r\n        sin.push([i, Math.sin(i/10)]);\r\n    }\r\n\r\n\r\n    $scope.dataupdate = false;\r\n\r\n    var init_load = false;\r\n\r\n    $scope.data2 = [\r\n        {\r\n            \"values\": sin,      //values - represents the array of {x,y} data points\r\n            key: 'Living Room Temp.', //key  - the name of the series.\r\n            color: '#ff7f0e',  //color - optional: choose your own line color.\r\n            strokeWidth: 3,\r\n            classed: 'dashed'\r\n        }\r\n    ];\r\n\r\n    function loaddata() {\r\n        $scope.dataupdate = false;\r\n        console.log(\"loaded record:\", temp);\r\n        $scope.data2[0].values = [];\r\n\r\n     for (var i=0;i<temp.length;i++){\r\n         //console.log(temp[i]['room temperature']);\r\n         console.log('date',Date.parse('2015 April 4'));\r\n         //$scope.data2[0].values.push([Date.parse('2015 April 4'),23]);\r\n         //$scope.data2[0].values.push([Date.parse('2015 April 5'),24]);\r\n         //$scope.data2[0].values.push([Date.parse('2015 April 6'),25]);\r\n         //$scope.data2[0].values.push([Date.parse('2015 April 7'),27]);\r\n         // var d = Date.parse('2015 April 4');\r\n         var temperature = temp[i]['temperature'];        \r\n         console.log([i, temperature]);\r\n         $scope.data2[0].values.push([i, temperature]);\r\n     }\r\n\r\n    };\r\n\r\n\r\n\r\n\r\n//    $scope.callAtInterval = loaddata;\r\n      \r\n    //init load of data at program start \r\n    // if (init_load == false) {\r\n    //     loaddata();\r\n    //     init_load = true;\r\n    // }\r\n\r\n    //var stopTime = $interval(function () { $scope.callAtInterval(); }, update_interval, false);\r\n\r\n    $scope.options2 = {\r\n        chart: {\r\n            type: 'lineChart',\r\n            height: 450,\r\n            margin: {\r\n                top: 20,\r\n                right: 20,\r\n                bottom: 80,\r\n                left: 55\r\n            },\r\n            x: function (d) { return d[0]; },\r\n            y: function (d) { return d[1]; },\r\n            useInteractiveGuideline: true,\r\n            dispatch: {\r\n                stateChange: function (e) { console.log(\"stateChange\"); },\r\n                changeState: function (e) { console.log(\"changeState\"); },\r\n                tooltipShow: function (e) { console.log(\"tooltipShow\"); },\r\n                tooltipHide: function (e) { console.log(\"tooltipHide\"); }\r\n            },\r\n            xAxis: {\r\n                axisLabel: 'Time',\r\n                tickFormat: function (d) {\r\n                    //return d3.time.format('%x')(new Date(d))\r\n                    return d3.format(',.1f')(d);\r\n\r\n                },\r\n                rotateLabels: 30,\r\n                showMaxMin: false\r\n            },\r\n            yAxis: {\r\n                axisLabel: 'Temperature CÂ°',\r\n                axisLabelDistance: -10,\r\n                tickFormat: function (d) {\r\n                    return d3.format(',.1f')(d);\r\n                }\r\n            },\r\n\r\n\r\n            callback: function (chart) {\r\n                // console.log(\"!!! lineChart callback !!!\");\r\n            },\r\n            zoom: {\r\n                enabled: true,\r\n                scaleExtent: [1, 20],\r\n                useFixedDomain: false,\r\n                useNiceScale: false,\r\n                horizontalOff: false,\r\n                verticalOff: true,\r\n                unzoomEventType: 'dblclick.zoom'\r\n            }\r\n        },\r\n        title: {\r\n            enable: true,\r\n            text: 'Temperature'\r\n        }\r\n    };\r\n\r\n        //  $element.on('$destroy', function() {\r\n        //     $interval.cancel(stopTime);\r\n        //   });\r\n\r\n}","app.controller('MainCtrl', ['$scope', '$cookieStore', MainCtrl]);\r\n\r\nfunction MainCtrl($scope, $cookieStore) {\r\n    /**\r\n     * Sidebar Toggle & Cookie Control\r\n     */\r\n\r\n    var mobileView = 992;\r\n\r\n    $scope.getWidth = function () {\r\n        return window.innerWidth;\r\n    };\r\n\r\n    $scope.$watch($scope.getWidth, function (newValue, oldValue) {\r\n        if (newValue >= mobileView) {\r\n            if (angular.isDefined($cookieStore.get('toggle'))) {\r\n                $scope.toggle = !$cookieStore.get('toggle') ? false : true;\r\n            } else {\r\n                $scope.toggle = true;\r\n            }\r\n        } else {\r\n            $scope.toggle = false;\r\n        }\r\n\r\n    });\r\n\r\n    $scope.toggleSidebar = function () {\r\n        $scope.toggle = !$scope.toggle;\r\n        $cookieStore.put('toggle', $scope.toggle);\r\n    };\r\n\r\n    window.onresize = function () {\r\n        $scope.$apply();\r\n    };\r\n}"],"preExisting":"//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvanMvYXBwLmpzIiwic3JjL2pzL2N0cmwvZGF0YXZpZXcuY29udHJvbGxlci5qcyIsInNyYy9qcy9jdHJsL2dlb3NwYXRpYWwuY29udHJvbGxlci5qcyIsInNyYy9qcy9jdHJsL2tleW1ldHJpY3MuY29udHJvbGxlci5qcyIsInNyYy9qcy9jdHJsL21haW4uY29udHJvbGxlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ2YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyJywgJ3VpLmJvb3RzdHJhcCcsICdmaXJlYmFzZScsICduZ0Nvb2tpZXMnLCd1aUdtYXBnb29nbGUtbWFwcycsJ252ZDMnLCduZ1RhYmxlJ10pOy8vLCBcclxuXHJcbmFwcC5jb25maWcoWyckc3RhdGVQcm92aWRlcicsICckdXJsUm91dGVyUHJvdmlkZXInLFxyXG4gICAgZnVuY3Rpb24gKCRzdGF0ZVByb3ZpZGVyLCAkdXJsUm91dGVyUHJvdmlkZXIpIHtcclxuXHJcbiAgICAgICAgLy9Qcm9ibGVtIHdpdGggaW5qZWN0aW9uXHJcbiAgICAgICAgLy8sJHN0YXRlUGFyYW1zXHJcblxyXG4gICAgICAgIC8vIEZvciB1bm1hdGNoZWQgcm91dGVzXHJcbiAgICAgICAgJHVybFJvdXRlclByb3ZpZGVyLm90aGVyd2lzZSgnLycpO1xyXG5cclxuICAgICAgICAvLyBBcHBsaWNhdGlvbiByb3V0ZXNcclxuICAgICAgICAkc3RhdGVQcm92aWRlclxyXG4gICAgICAgICAgICAuc3RhdGUoJ2luZGV4Jywge1xyXG4gICAgICAgICAgICAgICAgdXJsOiAnLycsXHJcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2xheW91dHMvZGFzaGJvYXJkLmh0bWwnXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zdGF0ZSgnZGF0YScsIHtcclxuICAgICAgICAgICAgICAgIHVybDogJy9kYXRhJyxcclxuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnbGF5b3V0cy9kYXRhLmh0bWwnXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zdGF0ZSgna2V5bWV0cmljcycsIHtcclxuICAgICAgICAgICAgICAgIHVybDogJy9rZXltZXRyaWNzJyxcclxuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnbGF5b3V0cy9rZXltZXRyaWNzLmh0bWwnXHJcbiAgICAgICAgICAgIH0pICAgICAgICAgICAgXHJcbiAgICB9XHJcbl0pO1xyXG5cclxuLyoqXHJcbiAqIFdpZGdldCBIZWFkZXIgRGlyZWN0aXZlXHJcbiAqL1xyXG5cclxuYXBwLmRpcmVjdGl2ZSgncmRXaWRnZXRIZWFkZXInLCByZFdpZGdldFRpdGxlKTtcclxuXHJcbmZ1bmN0aW9uIHJkV2lkZ2V0VGl0bGUoKSB7XHJcbiAgICB2YXIgZGlyZWN0aXZlID0ge1xyXG4gICAgICAgIHJlcXVpcmVzOiAnXnJkV2lkZ2V0JyxcclxuICAgICAgICBzY29wZToge1xyXG4gICAgICAgICAgICB0aXRsZTogJ0AnLFxyXG4gICAgICAgICAgICBpY29uOiAnQCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICAgICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwid2lkZ2V0LWhlYWRlclwiPjxkaXYgY2xhc3M9XCJyb3dcIj48ZGl2IGNsYXNzPVwicHVsbC1sZWZ0XCI+PGkgY2xhc3M9XCJmYVwiIG5nLWNsYXNzPVwiaWNvblwiPjwvaT4ge3t0aXRsZX19IDwvZGl2PjxkaXYgY2xhc3M9XCJwdWxsLXJpZ2h0IGNvbC14cy02IGNvbC1zbS00XCIgbmctdHJhbnNjbHVkZT48L2Rpdj48L2Rpdj48L2Rpdj4nLFxyXG4gICAgICAgIHJlc3RyaWN0OiAnRSdcclxuICAgIH07XHJcbiAgICByZXR1cm4gZGlyZWN0aXZlO1xyXG59O1xyXG5cclxuYXBwLmRpcmVjdGl2ZSgncmRXaWRnZXRGb290ZXInLCByZFdpZGdldEZvb3Rlcik7XHJcblxyXG5mdW5jdGlvbiByZFdpZGdldEZvb3RlcigpIHtcclxuICAgIHZhciBkaXJlY3RpdmUgPSB7XHJcbiAgICAgICAgcmVxdWlyZXM6ICdecmRXaWRnZXQnLFxyXG4gICAgICAgIHRyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICAgICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwid2lkZ2V0LWZvb3RlclwiIG5nLXRyYW5zY2x1ZGU+PC9kaXY+JyxcclxuICAgICAgICByZXN0cmljdDogJ0UnXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGRpcmVjdGl2ZTtcclxufTtcclxuXHJcblxyXG5hcHAuZGlyZWN0aXZlKCdyZFdpZGdldEJvZHknLCByZFdpZGdldEJvZHkpO1xyXG5cclxuZnVuY3Rpb24gcmRXaWRnZXRCb2R5KCkge1xyXG4gICAgdmFyIGRpcmVjdGl2ZSA9IHtcclxuICAgICAgICByZXF1aXJlczogJ15yZFdpZGdldCcsXHJcbiAgICAgICAgc2NvcGU6IHtcclxuICAgICAgICAgICAgbG9hZGluZzogJ0A/JyxcclxuICAgICAgICAgICAgY2xhc3NlczogJ0A/J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgICAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJ3aWRnZXQtYm9keVwiIG5nLWNsYXNzPVwiY2xhc3Nlc1wiPjxyZC1sb2FkaW5nIG5nLXNob3c9XCJsb2FkaW5nXCI+PC9yZC1sb2FkaW5nPjxkaXYgbmctaGlkZT1cImxvYWRpbmdcIiBjbGFzcz1cIndpZGdldC1jb250ZW50XCIgbmctdHJhbnNjbHVkZT48L2Rpdj48L2Rpdj4nLFxyXG4gICAgICAgIHJlc3RyaWN0OiAnRSdcclxuICAgIH07XHJcbiAgICByZXR1cm4gZGlyZWN0aXZlO1xyXG59O1xyXG5cclxuYXBwLmRpcmVjdGl2ZSgncmRXaWRnZXQnLCByZFdpZGdldCk7XHJcblxyXG5mdW5jdGlvbiByZFdpZGdldCgpIHtcclxuICAgIHZhciBkaXJlY3RpdmUgPSB7XHJcbiAgICAgICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgICAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJ3aWRnZXRcIiBuZy10cmFuc2NsdWRlPjwvZGl2PicsXHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFQSdcclxuICAgIH07XHJcbiAgICByZXR1cm4gZGlyZWN0aXZlO1xyXG5cclxuICAgIGZ1bmN0aW9uIGxpbmsoc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XHJcbiAgICAgICAgLyogKi9cclxuICAgIH1cclxufTtcclxuXHJcbmFwcC5kaXJlY3RpdmUoJ3JkTG9hZGluZycsIHJkTG9hZGluZyk7XHJcblxyXG5mdW5jdGlvbiByZExvYWRpbmcoKSB7XHJcbiAgICB2YXIgZGlyZWN0aXZlID0ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnQUUnLFxyXG4gICAgICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cImxvYWRpbmdcIj48ZGl2IGNsYXNzPVwiZG91YmxlLWJvdW5jZTFcIj48L2Rpdj48ZGl2IGNsYXNzPVwiZG91YmxlLWJvdW5jZTJcIj48L2Rpdj48L2Rpdj4nXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGRpcmVjdGl2ZTtcclxufTtcclxuXHJcbiIsImFwcC5jb250cm9sbGVyKCdEYXRhVmlld0N0cmwnLCBbJyRzY29wZScsICckZWxlbWVudCcsICckd2luZG93JywgJyRodHRwJywgJyRpbnRlcnZhbCcsICdOZ1RhYmxlUGFyYW1zJywgRGF0YVZpZXdDdHJsXSk7XHJcblxyXG5mdW5jdGlvbiBEYXRhVmlld0N0cmwoJHNjb3BlLCAkZWxlbWVudCwgJHdpbmRvdywgJGh0dHAsICRpbnRlcnZhbCwgTmdUYWJsZVBhcmFtcykge1xyXG5cclxuICAgIHZhciB1cGRhdGVfaW50ZXJ2YWwgPSAzMDAwO1xyXG5cclxuICAgIHZhciBtb2JpbGVWaWV3ID0gOTkyO1xyXG5cclxuICAgICRzY29wZS5kYXRhdXBkYXRlID0gZmFsc2U7XHJcblxyXG4gICAgJHNjb3BlLm1vYmlsZXRhYmxlID0gW107XHJcblxyXG4gICAgJHNjb3BlLmlmcmFtZUhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcclxuXHJcblxyXG4gICAgdmFyIHcgPSBhbmd1bGFyLmVsZW1lbnQoJHdpbmRvdyk7XHJcbiAgICAkc2NvcGUuJHdhdGNoKFxyXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICR3aW5kb3cuaW5uZXJXaWR0aDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAkc2NvcGUud2luZG93V2lkdGggPSB2YWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRydWVcclxuICAgICAgICApO1xyXG5cclxuICAgIHcuYmluZCgncmVzaXplJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICRzY29wZS4kYXBwbHkoKTtcclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICAkc2NvcGUuaXNzdWVzY2xvc2VkID0gMDtcclxuICAgICRzY29wZS5pc3N1ZXNvcGVuID0gMDtcclxuXHJcbiAgICB2YXIgaW5pdF9sb2FkID0gZmFsc2U7XHJcblxyXG4gICAgZnVuY3Rpb24gbG9hZGRhdGEoKSB7XHJcblxyXG4gICAgICAgICRzY29wZS5kYXRhdXBkYXRlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGQzLmNzdihcImRhdGEvaXNzdWVzLmNzdlwiLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgY3VzdG9tZXJuYW1lOiBkWydDdXN0b21lciBuYW1lJ10sXHJcbiAgICAgICAgICAgICAgICBzdWJ0aW1lc3RhbXA6IERhdGUucGFyc2UoZFsnU3VibWlzc2lvbiBUaW1lc3RhbXAnXSksXHJcbiAgICAgICAgICAgICAgICBlbWFpbDogZFsnY3VzdG9tZXIgZW1haWwgYWRkcmVzcyddLFxyXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGRbJ0Rlc2NyaXB0aW9uJ10sXHJcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGRbJ1N0YXR1cyddLFxyXG4gICAgICAgICAgICAgICAgY2xvc2VkdGltZXN0YW1wOiBEYXRlLnBhcnNlKGRbJ0Nsb3NlZCBUaW1lc3RhbXAnXSksXHJcbiAgICAgICAgICAgICAgICBlbXBsb3llZW5hbWU6IGRbJ0VtcGxveWVlIG5hbWUnXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgICRzY29wZS5pc3N1ZXNjbG9zZWQgPSAwO1xyXG4gICAgICAgICAgICAkc2NvcGUuaXNzdWVzb3BlbiA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0uc3RhdHVzID09IFwiQ2xvc2VkXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuaXNzdWVzY2xvc2VkID0gJHNjb3BlLmlzc3Vlc2Nsb3NlZCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0lzc3VlIG9wZW4nLCAkc2NvcGUuaXNzdWVzY2xvc2VkKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmlzc3Vlc29wZW4gPSAkc2NvcGUuaXNzdWVzb3BlbiArIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICRzY29wZS5tb2JpbGV0YWJsZSA9IGRhdGE7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRGF0YSEhIScsIGRhdGEpO1xyXG5cclxuICAgICAgICAgICAgJHNjb3BlLnRwID0gbmV3IE5nVGFibGVQYXJhbXMoe30sIHsgZGF0YXNldDogZGF0YSB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgICRzY29wZS5jYWxsQXRJbnRlcnZhbCA9IGxvYWRkYXRhO1xyXG4gICAgICBcclxuICAgIC8vaW5pdCBsb2FkIG9mIGRhdGEgYXQgcHJvZ3JhbSBzdGFydCBcclxuICAgIGlmIChpbml0X2xvYWQgPT0gZmFsc2UpIHtcclxuICAgICAgICBsb2FkZGF0YSgpO1xyXG4gICAgICAgIGluaXRfbG9hZCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHN0b3BUaW1lID0gJGludGVydmFsKGZ1bmN0aW9uICgpIHsgJHNjb3BlLmNhbGxBdEludGVydmFsKCk7IH0sIHVwZGF0ZV9pbnRlcnZhbCwgZmFsc2UpO1xyXG5cclxuICAgICRlbGVtZW50Lm9uKCckZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAkaW50ZXJ2YWwuY2FuY2VsKHN0b3BUaW1lKTtcclxuICAgIH0pO1xyXG5cclxuXHJcbn0iLCJhcHAuY29udHJvbGxlcignR2VvU3BhdGlhbEN0cmwnLCBbJyRzY29wZScsICckZWxlbWVudCcsICckaHR0cCcsICckaW50ZXJ2YWwnLCAnTmdUYWJsZVBhcmFtcycsIEdlb1NwYXRpYWxDdHJsXSk7XHJcblxyXG5mdW5jdGlvbiBHZW9TcGF0aWFsQ3RybCgkc2NvcGUsICRlbGVtZW50LCAkaHR0cCwgJGludGVydmFsLCBOZ1RhYmxlUGFyYW1zKSB7XHJcbiAgICBcclxuICAgIHZhciB1cGRhdGVfaW50ZXJ2YWwgPSAzMDAwO1xyXG5cclxuICAgICRzY29wZS5kYXRhdXBkYXRlID0gZmFsc2U7XHJcblxyXG4gICAgJHNjb3BlLm1hcCA9IHsgY2VudGVyOiB7IGxhdGl0dWRlOiA0OC4yMDcwNTc3NSwgbG9uZ2l0dWRlOiAxNi4zODA0NDM1NyB9LCB6b29tOiA4IH07XHJcblxyXG4gICAgJHNjb3BlLnBsYWNlcyA9IFtdO1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBsb2FkZGF0YSgpIHtcclxuICAgICAgICBcclxuICAgICAgICAkc2NvcGUuZGF0YXVwZGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgIFxyXG4gICAgICAgICRodHRwLmdldChcImRhdGEvc3RhdGlvbnMuanNvblwiKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5zdGF0aW9ucztcclxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChwbGFjZXMpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICgkc2NvcGUucGxhY2VzLmxlbmd0aCAhPSBwbGFjZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YXVwZGF0ZSA9ICEkc2NvcGUuZGF0YXVwZGF0ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoJHNjb3BlLnBsYWNlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbGFjZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBsYWNlc1tpXS50aXRsZSAhPSAkc2NvcGUucGxhY2VzW2ldLnRpdGxlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCckc2NvcGUucGxhY2VzW2ldeHgnLCRzY29wZS5wbGFjZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ05FIGNoZWNrJyxwbGFjZXNbaV0udGl0bGUsJHNjb3BlLnBsYWNlc1tpXS50aXRsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YXVwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBsYWNlc1tpXS5lbXBsb3llZXMgIT0gJHNjb3BlLnBsYWNlc1tpXS5lbXBsb3llZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhdXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCckc2NvcGUuZGF0YXVwZGF0ZScsJHNjb3BlLmRhdGF1cGRhdGUpO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbGFjZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHBsYWNlc1tpXVsnb3B0aW9ucyddID0geyBsYWJlbENsYXNzOiAnbGFiZWxzJywgbGFiZWxBbmNob3I6ICcxMiA2MCcsIGxhYmVsQ29udGVudDogcGxhY2VzW2ldLnRpdGxlICsgJyAsIGVtcGxveWVlczogJyArIHBsYWNlc1tpXS5lbXBsb3llZXMgfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgJHNjb3BlLnBsYWNlcyA9IHBsYWNlcztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAkc2NvcGUuY2FsbEF0SW50ZXJ2YWwgPSBsb2FkZGF0YTtcclxuXHJcbiAgICB2YXIgc3RvcFRpbWUgPSAkaW50ZXJ2YWwoZnVuY3Rpb24gKCkgeyAkc2NvcGUuY2FsbEF0SW50ZXJ2YWwoKTsgfSwgdXBkYXRlX2ludGVydmFsLCBmYWxzZSk7XHJcblxyXG4gICAgJGVsZW1lbnQub24oJyRkZXN0cm95JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICRpbnRlcnZhbC5jYW5jZWwoc3RvcFRpbWUpO1xyXG4gICAgfSk7XHJcblxyXG5cclxuXHJcblxyXG59IiwiYXBwLmNvbnRyb2xsZXIoJ0tleU1ldHJpY3NDdHJsJywgWyckc2NvcGUnLCAnJGVsZW1lbnQnLCAnJGh0dHAnLCAnJGludGVydmFsJywgJ05nVGFibGVQYXJhbXMnLCAnJGZpcmViYXNlQXJyYXknLCAgS2V5TWV0cmljc0N0cmxdKTtcclxuXHJcbmZ1bmN0aW9uIEtleU1ldHJpY3NDdHJsKCRzY29wZSwgJGVsZW1lbnQsICRodHRwLCAkaW50ZXJ2YWwsIE5nVGFibGVQYXJhbXMsICRmaXJlYmFzZUFycmF5KSB7XHJcblxyXG4gICAgdmFyIHVwZGF0ZV9pbnRlcnZhbCA9IDMwMDA7XHJcblxyXG4gICAgdmFyIG1vYmlsZVZpZXcgPSA5OTI7XHJcbiAgICBcclxuICAgIHZhciByZWYgPSBuZXcgRmlyZWJhc2UoXCJodHRwczovL2ZsaWNrZXJpbmctaW5mZXJuby02OTE3LmZpcmViYXNlaW8uY29tL3RlbXBlcmF0dXJlXCIpO1xyXG5cclxuICAgIHZhciB0ZW1wID0gJGZpcmViYXNlQXJyYXkocmVmKTtcclxuXHJcbiAgICB2YXIgc2luID0gW107XHJcblxyXG4gICAgIC8vIHRvIHRha2UgYW4gYWN0aW9uIGFmdGVyIHRoZSBkYXRhIGxvYWRzLCB1c2UgdGhlICRsb2FkZWQoKSBwcm9taXNlXHJcbiAgICAgdGVtcC4kbG9hZGVkKCkudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcImxvYWRlZCByZWNvcmQ6XCIsIHRlbXApO1xyXG4gICAgICAgIGxvYWRkYXRhKCk7XHJcbiAgICAgICAvLyBUbyBpdGVyYXRlIHRoZSBrZXkvdmFsdWUgcGFpcnMgb2YgdGhlIG9iamVjdCwgdXNlIGFuZ3VsYXIuZm9yRWFjaCgpXHJcbiAgICAgfSk7XHJcblxyXG4gICAgLy9EYXRhIGlzIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIHt4LHl9IHBhaXJzLlxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xyXG4gICAgICAgIHNpbi5wdXNoKFtpLCBNYXRoLnNpbihpLzEwKV0pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAkc2NvcGUuZGF0YXVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuICAgIHZhciBpbml0X2xvYWQgPSBmYWxzZTtcclxuXHJcbiAgICAkc2NvcGUuZGF0YTIgPSBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBcInZhbHVlc1wiOiBzaW4sICAgICAgLy92YWx1ZXMgLSByZXByZXNlbnRzIHRoZSBhcnJheSBvZiB7eCx5fSBkYXRhIHBvaW50c1xyXG4gICAgICAgICAgICBrZXk6ICdMaXZpbmcgUm9vbSBUZW1wLicsIC8va2V5ICAtIHRoZSBuYW1lIG9mIHRoZSBzZXJpZXMuXHJcbiAgICAgICAgICAgIGNvbG9yOiAnI2ZmN2YwZScsICAvL2NvbG9yIC0gb3B0aW9uYWw6IGNob29zZSB5b3VyIG93biBsaW5lIGNvbG9yLlxyXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMyxcclxuICAgICAgICAgICAgY2xhc3NlZDogJ2Rhc2hlZCdcclxuICAgICAgICB9XHJcbiAgICBdO1xyXG5cclxuICAgIGZ1bmN0aW9uIGxvYWRkYXRhKCkge1xyXG4gICAgICAgICRzY29wZS5kYXRhdXBkYXRlID0gZmFsc2U7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJsb2FkZWQgcmVjb3JkOlwiLCB0ZW1wKTtcclxuICAgICAgICAkc2NvcGUuZGF0YTJbMF0udmFsdWVzID0gW107XHJcblxyXG4gICAgIGZvciAodmFyIGk9MDtpPHRlbXAubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgIC8vY29uc29sZS5sb2codGVtcFtpXVsncm9vbSB0ZW1wZXJhdHVyZSddKTtcclxuICAgICAgICAgY29uc29sZS5sb2coJ2RhdGUnLERhdGUucGFyc2UoJzIwMTUgQXByaWwgNCcpKTtcclxuICAgICAgICAgLy8kc2NvcGUuZGF0YTJbMF0udmFsdWVzLnB1c2goW0RhdGUucGFyc2UoJzIwMTUgQXByaWwgNCcpLDIzXSk7XHJcbiAgICAgICAgIC8vJHNjb3BlLmRhdGEyWzBdLnZhbHVlcy5wdXNoKFtEYXRlLnBhcnNlKCcyMDE1IEFwcmlsIDUnKSwyNF0pO1xyXG4gICAgICAgICAvLyRzY29wZS5kYXRhMlswXS52YWx1ZXMucHVzaChbRGF0ZS5wYXJzZSgnMjAxNSBBcHJpbCA2JyksMjVdKTtcclxuICAgICAgICAgLy8kc2NvcGUuZGF0YTJbMF0udmFsdWVzLnB1c2goW0RhdGUucGFyc2UoJzIwMTUgQXByaWwgNycpLDI3XSk7XHJcbiAgICAgICAgIC8vIHZhciBkID0gRGF0ZS5wYXJzZSgnMjAxNSBBcHJpbCA0Jyk7XHJcbiAgICAgICAgIHZhciB0ZW1wZXJhdHVyZSA9IHRlbXBbaV1bJ3RlbXBlcmF0dXJlJ107ICAgICAgICBcclxuICAgICAgICAgY29uc29sZS5sb2coW2ksIHRlbXBlcmF0dXJlXSk7XHJcbiAgICAgICAgICRzY29wZS5kYXRhMlswXS52YWx1ZXMucHVzaChbaSwgdGVtcGVyYXR1cmVdKTtcclxuICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcblxyXG5cclxuXHJcbi8vICAgICRzY29wZS5jYWxsQXRJbnRlcnZhbCA9IGxvYWRkYXRhO1xyXG4gICAgICBcclxuICAgIC8vaW5pdCBsb2FkIG9mIGRhdGEgYXQgcHJvZ3JhbSBzdGFydCBcclxuICAgIC8vIGlmIChpbml0X2xvYWQgPT0gZmFsc2UpIHtcclxuICAgIC8vICAgICBsb2FkZGF0YSgpO1xyXG4gICAgLy8gICAgIGluaXRfbG9hZCA9IHRydWU7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgLy92YXIgc3RvcFRpbWUgPSAkaW50ZXJ2YWwoZnVuY3Rpb24gKCkgeyAkc2NvcGUuY2FsbEF0SW50ZXJ2YWwoKTsgfSwgdXBkYXRlX2ludGVydmFsLCBmYWxzZSk7XHJcblxyXG4gICAgJHNjb3BlLm9wdGlvbnMyID0ge1xyXG4gICAgICAgIGNoYXJ0OiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdsaW5lQ2hhcnQnLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDQ1MCxcclxuICAgICAgICAgICAgbWFyZ2luOiB7XHJcbiAgICAgICAgICAgICAgICB0b3A6IDIwLFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6IDIwLFxyXG4gICAgICAgICAgICAgICAgYm90dG9tOiA4MCxcclxuICAgICAgICAgICAgICAgIGxlZnQ6IDU1XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHg6IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWzBdOyB9LFxyXG4gICAgICAgICAgICB5OiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsxXTsgfSxcclxuICAgICAgICAgICAgdXNlSW50ZXJhY3RpdmVHdWlkZWxpbmU6IHRydWUsXHJcbiAgICAgICAgICAgIGRpc3BhdGNoOiB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZUNoYW5nZTogZnVuY3Rpb24gKGUpIHsgY29uc29sZS5sb2coXCJzdGF0ZUNoYW5nZVwiKTsgfSxcclxuICAgICAgICAgICAgICAgIGNoYW5nZVN0YXRlOiBmdW5jdGlvbiAoZSkgeyBjb25zb2xlLmxvZyhcImNoYW5nZVN0YXRlXCIpOyB9LFxyXG4gICAgICAgICAgICAgICAgdG9vbHRpcFNob3c6IGZ1bmN0aW9uIChlKSB7IGNvbnNvbGUubG9nKFwidG9vbHRpcFNob3dcIik7IH0sXHJcbiAgICAgICAgICAgICAgICB0b29sdGlwSGlkZTogZnVuY3Rpb24gKGUpIHsgY29uc29sZS5sb2coXCJ0b29sdGlwSGlkZVwiKTsgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB4QXhpczoge1xyXG4gICAgICAgICAgICAgICAgYXhpc0xhYmVsOiAnVGltZScsXHJcbiAgICAgICAgICAgICAgICB0aWNrRm9ybWF0OiBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIGQzLnRpbWUuZm9ybWF0KCcleCcpKG5ldyBEYXRlKGQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkMy5mb3JtYXQoJywuMWYnKShkKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcm90YXRlTGFiZWxzOiAzMCxcclxuICAgICAgICAgICAgICAgIHNob3dNYXhNaW46IGZhbHNlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHlBeGlzOiB7XHJcbiAgICAgICAgICAgICAgICBheGlzTGFiZWw6ICdUZW1wZXJhdHVyZSBDwrAnLFxyXG4gICAgICAgICAgICAgICAgYXhpc0xhYmVsRGlzdGFuY2U6IC0xMCxcclxuICAgICAgICAgICAgICAgIHRpY2tGb3JtYXQ6IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQzLmZvcm1hdCgnLC4xZicpKGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoY2hhcnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiISEhIGxpbmVDaGFydCBjYWxsYmFjayAhISFcIik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHpvb206IHtcclxuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzY2FsZUV4dGVudDogWzEsIDIwXSxcclxuICAgICAgICAgICAgICAgIHVzZUZpeGVkRG9tYWluOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHVzZU5pY2VTY2FsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsT2ZmOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHZlcnRpY2FsT2ZmOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgdW56b29tRXZlbnRUeXBlOiAnZGJsY2xpY2suem9vbSdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdGl0bGU6IHtcclxuICAgICAgICAgICAgZW5hYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB0ZXh0OiAnVGVtcGVyYXR1cmUnXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAgICAgLy8gICRlbGVtZW50Lm9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vICAgICAkaW50ZXJ2YWwuY2FuY2VsKHN0b3BUaW1lKTtcclxuICAgICAgICAvLyAgIH0pO1xyXG5cclxufSIsImFwcC5jb250cm9sbGVyKCdNYWluQ3RybCcsIFsnJHNjb3BlJywgJyRjb29raWVTdG9yZScsIE1haW5DdHJsXSk7XHJcblxyXG5mdW5jdGlvbiBNYWluQ3RybCgkc2NvcGUsICRjb29raWVTdG9yZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTaWRlYmFyIFRvZ2dsZSAmIENvb2tpZSBDb250cm9sXHJcbiAgICAgKi9cclxuXHJcbiAgICB2YXIgbW9iaWxlVmlldyA9IDk5MjtcclxuXHJcbiAgICAkc2NvcGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lcldpZHRoO1xyXG4gICAgfTtcclxuXHJcbiAgICAkc2NvcGUuJHdhdGNoKCRzY29wZS5nZXRXaWR0aCwgZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xyXG4gICAgICAgIGlmIChuZXdWYWx1ZSA+PSBtb2JpbGVWaWV3KSB7XHJcbiAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZCgkY29va2llU3RvcmUuZ2V0KCd0b2dnbGUnKSkpIHtcclxuICAgICAgICAgICAgICAgICRzY29wZS50b2dnbGUgPSAhJGNvb2tpZVN0b3JlLmdldCgndG9nZ2xlJykgPyBmYWxzZSA6IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAkc2NvcGUudG9nZ2xlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICRzY29wZS50b2dnbGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgJHNjb3BlLnRvZ2dsZVNpZGViYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgJHNjb3BlLnRvZ2dsZSA9ICEkc2NvcGUudG9nZ2xlO1xyXG4gICAgICAgICRjb29raWVTdG9yZS5wdXQoJ3RvZ2dsZScsICRzY29wZS50b2dnbGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICB3aW5kb3cub25yZXNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xyXG4gICAgfTtcclxufSJdfQ=="}